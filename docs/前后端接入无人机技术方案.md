# 前后端接入无人机技术方案

> 目标：结合现有 React 前端与 Spring Boot 后端，利用 MQTT 协议完成无人机的“接入/登记/建链/心跳”全流程，并确保易于模拟测试。

## 1. 整体架构

```
[UAV 仿真脚本 / 真实设备]
        │ MQTT(JSON 心跳/命令确认)
        ▼
[MQTT Broker (EMQX/Mosquitto)]
        │ 1) 心跳/指标 upstream  topic: uav/{uavId}/telemetry
        │ 2) 控制/响应 downstream topic: uav/{uavId}/command
        ▼
[Spring Boot 服务]
 ├─ Device Registry Service  (REST 接口 / DB)
 ├─ Telemetry Consumer       (MQTT -> WebSocket / 数据存储)
 ├─ Command Gateway          (REST -> MQTT 指令)
 └─ WebSocket Gateway        (推送给前端)
        ▼
[PostgreSQL/Redis]
        ▼
[前端 React / `POST /api/fleet` 等接口]
```

- **MQTT 协议**：消息体使用 JSON，字段便于脚本模拟（`mosquitto_pub -t uav/UAV-21/telemetry -m '{...}'`）。
- **后端**：Spring Boot 3 + Spring Security + Spring Data JPA + spring-mqtt；通过 `@Bean MqttPahoMessageDrivenChannelAdapter` 订阅设备心跳。
- **前端**：沿用 `FleetCenter` 接入弹窗，新增连接参数表单；调用 `POST /api/fleet` 提交。

## 2. 前端需提供的接入信息

| 字段 | 说明 | 举例 |
| --- | --- | --- |
| `uavId` | 可选。留空由后端生成 (`UAV-2024-021`) | `UAV-21` |
| `model` | 机型描述 | `多旋翼 · PX4 1.13` |
| `pilot` | 责任人 | `张三` |
| `status` | 初始状态（默认 `pending_connect`） | `pending_connect` |
| `connection.endpoint` | MQTT Broker 地址或代理域名，方便设备拨入 | `mqtts://broker.example.com:8883` |
| `connection.protocol` | 固定 `mqtt-json`，表示设备使用 MQTT + JSON 格式 | `mqtt-json` |
| `connection.topicPrefix` | 设备计划使用的主题。若空由服务端生成并返回 | `uav/UAV-21` |
| `connection.DeviceSecret` | 设备端的配对码/证书 ID，用于后端生成 MQTT 凭据 | `abc123` |
| `connection.telemetrySets` | 设备能上传的传感器列表（帮助后端建模） | `["battery","gps","ndvi"]` |

前端提交后，后台响应将包含后端生成的 `mqtt.username`, `mqtt.password`, `topicUp`, `topicDown`，供操作员配置到无人机或仿真脚本。任务绑定、电量、链路质量、RTT 等信息全部来源于后续遥测，不需要在接入阶段填写。

## 3. 后端组件设计

1. **Device Registry Service**
   - `POST /api/fleet`：写入 `uav_devices` 表，状态 `PENDING_CONNECT`。
   - 生成：`uavId`（若空）、`mqttUsername`, `mqttPassword`, `topicUp = uav/{uavId}/telemetry`, `topicDown = uav/{uavId}/command`。
   - 将 MQTT 凭据写入 Broker（EMQX Management API / 数据库同步）。
2. **MQTT 心跳消费者**
   - 订阅 `uav/+/telemetry`，监听 JSON：
     ```json
     {
       "ts": "2024-06-18T08:23:00Z",
       "battery": 74,
       "rangeKm": 12.5,
       "location": { "lat": 31.27, "lng": 121.46, "alt": 320 },
       "velocity": 12.3,
       "payload": { "surfaceTemp": 62.1 }
     }
     ```
   - 校验 `uavId`、更新 `uav_devices` 表的 `last_heartbeat`, `battery`, `range_km`, `status=ONLINE`。
   - 推送给前端 `ws/fleet-status`。
3. **MQTT 命令 Gateway**
   - 提供 `POST /api/fleet/{uavId}/command`，body 例如 `{"type":"RETURN_HOME"}`，转发到 `uav/{uavId}/command`。
4. **WebSocket Gateway**
   - 将心跳数据合并为 `uav.telemetry` 消息，携带 `rangeKm` 与 `location`。前端订阅。
5. **存储**
   - `uav_devices` 表：记录设备静态信息与连接状态。
   - `uav_sessions` 表：记录每次连接 sessionId、握手时间、MQTT clientId。
   - `uav_telemetry`（可选时序库）：写入历史指标。

## 4. 无人机端（或仿真脚本）实现建议

- 使用 Python + `paho-mqtt`（易模拟）或 Node.js `mqtt` 包。
- 启动参数包含：`--uavId UAV-21 --broker mqtts://... --username device_UAV-21 --password <server>`。
- 心跳发送周期 2s：
  ```python
  payload = {
      "ts": datetime.utcnow().isoformat(),
      "battery": 75,
      "rangeKm": calc_range(battery),
      "location": {"lat": lat, "lng": lng, "alt": alt},
      "velocity": speed,
      "payload": {
          "surfaceTemp": 61.2,
          "pm25": None
      }
  }
  client.publish("uav/UAV-21/telemetry", json.dumps(payload), qos=1)
  ```
- 当接收下行指令 `uav/UAV-21/command` 时返回确认：
  ```json
  {
    "ts": "2024-06-18T08:25:00Z",
    "type": "COMMAND_ACK",
    "commandId": "RETURN_HOME",
    "result": "ACCEPTED"
  }
  ```

## 5. 接入与建链时序

1. **前端**（FleetCenter -> “接入无人机”）填写表单并调用 `POST /api/fleet`。
2. **Spring Device Registry**：
   - 持久化记录。
   - 调用 MQTT Broker API 创建用户名/密码，并记录在表中。
   - 返回：`uavId`, `mqtt` 凭据、`topicUp`, `topicDown`。
3. **操作员配置无人机/脚本**：录入上述凭据，启动设备。
4. **无人机**：通过 MQTT 连接 broker，开始向 `topicUp` 发送心跳。
5. **Spring Telemetry Consumer**：收到消息后：
   - 验证签名（可选：payload 中带 `sign`）。
   - 更新数据库，广播 WebSocket。
   - 若首次连接，将 `status` 从 `PENDING_CONNECT` 更新为 `ONLINE`。
6. **前端**：通过 `ws/fleet-status` 收到 `uav.telemetry`，刷新表格/仪表盘；`status` 变为“在线”。
7. **异常/断线**：若 `last_heartbeat` 超过 10s 未更新，后端触发 `offline` 事件，推送 `status=critical`。

## 6. 数据模型（示例）

```sql
CREATE TABLE uav_devices (
  id               SERIAL PRIMARY KEY,
  uav_id           VARCHAR(32) UNIQUE,
  model            VARCHAR(64),
  pilot            VARCHAR(32),
  mission          VARCHAR(64),
  status           VARCHAR(20),        -- PENDING_CONNECT / ONLINE / WARNING / CRITICAL
  battery          INT,
  range_km         NUMERIC(6,2),
  link_quality     VARCHAR(10),
  rtt_ms           INT,
  last_heartbeat   TIMESTAMP,
  mqtt_username    VARCHAR(64),
  mqtt_password    VARCHAR(128),
  topic_up         VARCHAR(64),
  topic_down       VARCHAR(64),
  device_secret    VARCHAR(64),
  metadata         JSONB,
  created_at       TIMESTAMP DEFAULT now()
);
```

## 7. 仿真/测试方案

1. **Broker**：在开发环境起 `docker run -p 1883:1883 eclipse-mosquitto`，匿名访问或预设用户名。
2. **模拟脚本**：
   ```bash
   mosquitto_pub -h localhost -p 1883 -t uav/UAV-21/telemetry \
     -m '{"ts":"2024-06-18T08:23:00Z","battery":80,"rangeKm":15.2,"location":{"lat":31.27,"lng":121.46,"alt":320}}'
   ```
3. **回归**：断开脚本，验证后端 10 秒内发出 `status=critical` 推送；重新连接后恢复。
4. **自动化**：在 CI 中使用 `integration-test` profile，Mock MQTT Broker，断言 Spring `MqttMessageHandler` 能写入数据库并推送 WebSocket。

## 8. 扩展点

- 可引入 **设备证书**，MQTT 使用 TLS 双向认证；`device_secret` 替换为证书序列号。
- 如果要兼容 RTSP 视频，可在 `connection` 中追加 `videoEndpoint`，后端通过 WebRTC Gateway 转发。
- 对于批量接入，可开发导入 CSV/Excel 的功能，统一生成 MQTT 凭据并导出给操作员。

该方案保证了：前端提供的最小信息帮助后端登记、生成连接凭据；Spring + MQTT 负责实时通信；无人机端协议简单 JSON，方便开发与模拟。
